export class MetadataStream {
    options;
    controller = new AbortController();
    serverStream;
    consumerStream;
    streamPromise;
    constructor(options) {
        this.options = options;
        const [serverStream, consumerStream] = this.createTeeStreams();
        this.serverStream = serverStream;
        this.consumerStream = consumerStream;
        this.streamPromise = this.initializeServerStream();
    }
    createTeeStreams() {
        const readableSource = new ReadableStream({
            start: async (controller) => {
                for await (const value of this.options.source) {
                    controller.enqueue(value);
                }
                controller.close();
            },
        });
        return readableSource.tee();
    }
    initializeServerStream() {
        const serverStream = this.serverStream.pipeThrough(new TransformStream({
            async transform(chunk, controller) {
                controller.enqueue(JSON.stringify(chunk) + "\n");
            },
        }));
        return fetch(this.buildUrl(), {
            method: "POST",
            headers: this.options.headers ?? {},
            body: serverStream,
            signal: this.controller.signal,
            // @ts-expect-error
            duplex: "half",
        });
    }
    async wait() {
        return this.streamPromise.then(() => void 0);
    }
    [Symbol.asyncIterator]() {
        return streamToAsyncIterator(this.consumerStream);
    }
    buildUrl() {
        switch (this.options.version ?? "v1") {
            case "v1": {
                return `${this.options.baseUrl}/realtime/v1/streams/${this.options.runId}/${this.options.target ?? "self"}/${this.options.key}`;
            }
            case "v2": {
                return `${this.options.baseUrl}/realtime/v2/streams/${this.options.runId}/${this.options.key}`;
            }
        }
    }
}
async function* streamToAsyncIterator(stream) {
    const reader = stream.getReader();
    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done)
                return;
            yield value;
        }
    }
    finally {
        reader.releaseLock();
    }
}
//# sourceMappingURL=metadataStream.js.map