import { runMetadata } from "../run-metadata-api.js";
import { unboundedTimeout } from "../utils/timers.js";
import { preventMultipleWaits } from "./preventMultipleWaits.js";
export class DevRuntimeManager {
    _taskWaits = new Map();
    _batchWaits = new Map();
    _pendingCompletionNotifications = new Map();
    _preventMultipleWaits = preventMultipleWaits();
    disable() {
        // do nothing
    }
    async waitForDuration(ms) {
        await this._preventMultipleWaits(() => unboundedTimeout(ms));
    }
    async waitUntil(date) {
        return this.waitForDuration(date.getTime() - Date.now());
    }
    async waitForTask(params) {
        return this._preventMultipleWaits(async () => {
            const pendingCompletion = this._pendingCompletionNotifications.get(params.id);
            if (pendingCompletion) {
                this._pendingCompletionNotifications.delete(params.id);
                return pendingCompletion;
            }
            const promise = new Promise((resolve) => {
                this._taskWaits.set(params.id, { resolve });
            });
            await this.#tryFlushMetadata();
            return await promise;
        });
    }
    async waitForBatch(params) {
        return this._preventMultipleWaits(async () => {
            if (!params.runs.length) {
                return Promise.resolve({ id: params.id, items: [] });
            }
            const promise = Promise.all(params.runs.map((runId) => {
                return new Promise((resolve, reject) => {
                    const pendingCompletion = this._pendingCompletionNotifications.get(runId);
                    if (pendingCompletion) {
                        this._pendingCompletionNotifications.delete(runId);
                        resolve(pendingCompletion);
                        return;
                    }
                    this._taskWaits.set(runId, { resolve });
                });
            }));
            await this.#tryFlushMetadata();
            const results = await promise;
            return {
                id: params.id,
                items: results,
            };
        });
    }
    resumeTask(completion, runId) {
        const wait = this._taskWaits.get(runId);
        if (!wait) {
            // We need to store the completion in case the task is awaited later
            this._pendingCompletionNotifications.set(runId, completion);
            return;
        }
        wait.resolve(completion);
        this._taskWaits.delete(runId);
    }
    async #tryFlushMetadata() {
        try {
            await runMetadata.flush();
        }
        catch (err) { }
    }
}
//# sourceMappingURL=devRuntimeManager.js.map