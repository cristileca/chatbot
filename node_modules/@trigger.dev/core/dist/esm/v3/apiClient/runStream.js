import { EventSourceParserStream } from "eventsource-parser/stream";
import { createJsonErrorObject } from "../errors.js";
import { SubscribeRealtimeStreamChunkRawShape, SubscribeRunRawShape, } from "../schemas/api.js";
import { getEnvVar } from "../utils/getEnv.js";
import { conditionallyImportAndParsePacket, parsePacket, } from "../utils/ioSerialization.js";
import { ApiError } from "./errors.js";
import { createAsyncIterableReadable, LineTransformStream, zodShapeStream, } from "./stream.js";
export function runShapeStream(url, options) {
    const abortController = new AbortController();
    const streamFactory = new SSEStreamSubscriptionFactory(getEnvVar("TRIGGER_STREAM_URL", getEnvVar("TRIGGER_API_URL")) ?? "https://api.trigger.dev", {
        headers: options?.headers,
        signal: abortController.signal,
    });
    // If the user supplied AbortSignal is aborted, we should abort the internal controller
    options?.signal?.addEventListener("abort", () => {
        if (!abortController.signal.aborted) {
            abortController.abort();
        }
    }, { once: true });
    const runStreamInstance = zodShapeStream(SubscribeRunRawShape, url, {
        ...options,
        signal: abortController.signal,
        onError: (e) => {
            options?.onFetchError?.(e);
        },
    });
    const $options = {
        runShapeStream: runStreamInstance.stream,
        stopRunShapeStream: () => runStreamInstance.stop(30 * 1000),
        streamFactory: streamFactory,
        abortController,
        ...options,
    };
    return new RunSubscription($options);
}
// Real implementation for production
export class SSEStreamSubscription {
    url;
    options;
    constructor(url, options) {
        this.url = url;
        this.options = options;
    }
    async subscribe() {
        return fetch(this.url, {
            headers: {
                Accept: "text/event-stream",
                ...this.options.headers,
            },
            signal: this.options.signal,
        }).then((response) => {
            if (!response.ok) {
                throw ApiError.generate(response.status, {}, "Could not subscribe to stream", Object.fromEntries(response.headers));
            }
            if (!response.body) {
                throw new Error("No response body");
            }
            return response.body
                .pipeThrough(new TextDecoderStream())
                .pipeThrough(new EventSourceParserStream())
                .pipeThrough(new TransformStream({
                transform(chunk, controller) {
                    controller.enqueue(safeParseJSON(chunk.data));
                },
            }));
        });
    }
}
export class SSEStreamSubscriptionFactory {
    baseUrl;
    options;
    constructor(baseUrl, options) {
        this.baseUrl = baseUrl;
        this.options = options;
    }
    createSubscription(runId, streamKey, baseUrl) {
        if (!runId || !streamKey) {
            throw new Error("runId and streamKey are required");
        }
        const url = `${baseUrl ?? this.baseUrl}/realtime/v1/streams/${runId}/${streamKey}`;
        return new SSEStreamSubscription(url, this.options);
    }
}
// Real implementation for production
export class ElectricStreamSubscription {
    url;
    options;
    constructor(url, options) {
        this.url = url;
        this.options = options;
    }
    async subscribe() {
        return zodShapeStream(SubscribeRealtimeStreamChunkRawShape, this.url, this.options)
            .stream.pipeThrough(new TransformStream({
            transform(chunk, controller) {
                controller.enqueue(chunk.value);
            },
        }))
            .pipeThrough(new LineTransformStream())
            .pipeThrough(new TransformStream({
            transform(chunk, controller) {
                for (const line of chunk) {
                    controller.enqueue(safeParseJSON(line));
                }
            },
        }));
    }
}
export class RunSubscription {
    options;
    stream;
    packetCache = new Map();
    _closeOnComplete;
    _isRunComplete = false;
    constructor(options) {
        this.options = options;
        this._closeOnComplete =
            typeof options.closeOnComplete === "undefined" ? true : options.closeOnComplete;
        this.stream = createAsyncIterableReadable(this.options.runShapeStream, {
            transform: async (chunk, controller) => {
                const run = await this.transformRunShape(chunk);
                controller.enqueue(run);
                // only set the run to complete when finishedAt is set
                this._isRunComplete = !!run.finishedAt;
                if (this._closeOnComplete &&
                    this._isRunComplete &&
                    !this.options.abortController.signal.aborted) {
                    this.options.stopRunShapeStream();
                }
            },
        }, this.options.abortController.signal);
    }
    unsubscribe() {
        if (!this.options.abortController.signal.aborted) {
            this.options.abortController.abort();
        }
        this.options.stopRunShapeStream();
    }
    [Symbol.asyncIterator]() {
        return this.stream[Symbol.asyncIterator]();
    }
    getReader() {
        return this.stream.getReader();
    }
    withStreams() {
        // Keep track of which streams we've already subscribed to
        const activeStreams = new Set();
        return createAsyncIterableReadable(this.stream, {
            transform: async (run, controller) => {
                controller.enqueue({
                    type: "run",
                    run,
                });
                // Check for stream metadata
                if (run.metadata &&
                    "$$streams" in run.metadata &&
                    Array.isArray(run.metadata.$$streams)) {
                    for (const streamKey of run.metadata.$$streams) {
                        if (typeof streamKey !== "string") {
                            continue;
                        }
                        if (!activeStreams.has(streamKey)) {
                            activeStreams.add(streamKey);
                            const subscription = this.options.streamFactory.createSubscription(run.id, streamKey, this.options.client?.baseUrl);
                            // Start stream processing in the background
                            subscription
                                .subscribe()
                                .then((stream) => {
                                stream
                                    .pipeThrough(new TransformStream({
                                    transform(chunk, controller) {
                                        controller.enqueue({
                                            type: streamKey,
                                            chunk: chunk,
                                            run,
                                        });
                                    },
                                }))
                                    .pipeTo(new WritableStream({
                                    write(chunk) {
                                        controller.enqueue(chunk);
                                    },
                                }))
                                    .catch((error) => {
                                    console.error(`Error in stream ${streamKey}:`, error);
                                });
                            })
                                .catch((error) => {
                                console.error(`Error subscribing to stream ${streamKey}:`, error);
                            });
                        }
                    }
                }
            },
        }, this.options.abortController.signal);
    }
    async transformRunShape(row) {
        const payloadPacket = row.payloadType
            ? { data: row.payload ?? undefined, dataType: row.payloadType }
            : undefined;
        const outputPacket = row.outputType
            ? { data: row.output ?? undefined, dataType: row.outputType }
            : undefined;
        const [payload, output] = await Promise.all([
            { packet: payloadPacket, key: "payload" },
            { packet: outputPacket, key: "output" },
        ].map(async ({ packet, key }) => {
            if (!packet) {
                return;
            }
            const cachedResult = this.packetCache.get(`${row.friendlyId}/${key}`);
            if (typeof cachedResult !== "undefined") {
                return cachedResult;
            }
            const result = await conditionallyImportAndParsePacket(packet, this.options.client);
            this.packetCache.set(`${row.friendlyId}/${key}`, result);
            return result;
        }));
        const metadata = row.metadata && row.metadataType
            ? await parsePacket({ data: row.metadata, dataType: row.metadataType })
            : undefined;
        return {
            id: row.friendlyId,
            payload,
            output,
            createdAt: row.createdAt,
            updatedAt: row.updatedAt,
            taskIdentifier: row.taskIdentifier,
            number: row.number,
            status: apiStatusFromRunStatus(row.status),
            durationMs: row.usageDurationMs,
            costInCents: row.costInCents,
            baseCostInCents: row.baseCostInCents,
            tags: row.runTags ?? [],
            idempotencyKey: row.idempotencyKey ?? undefined,
            expiredAt: row.expiredAt ?? undefined,
            finishedAt: row.completedAt ?? undefined,
            startedAt: row.startedAt ?? undefined,
            delayedUntil: row.delayUntil ?? undefined,
            queuedAt: row.queuedAt ?? undefined,
            error: row.error ? createJsonErrorObject(row.error) : undefined,
            isTest: row.isTest,
            metadata,
        };
    }
}
function apiStatusFromRunStatus(status) {
    switch (status) {
        case "DELAYED": {
            return "DELAYED";
        }
        case "WAITING_FOR_DEPLOY": {
            return "WAITING_FOR_DEPLOY";
        }
        case "PENDING": {
            return "QUEUED";
        }
        case "PAUSED":
        case "WAITING_TO_RESUME": {
            return "FROZEN";
        }
        case "RETRYING_AFTER_FAILURE": {
            return "REATTEMPTING";
        }
        case "EXECUTING": {
            return "EXECUTING";
        }
        case "CANCELED": {
            return "CANCELED";
        }
        case "COMPLETED_SUCCESSFULLY": {
            return "COMPLETED";
        }
        case "SYSTEM_FAILURE": {
            return "SYSTEM_FAILURE";
        }
        case "INTERRUPTED": {
            return "INTERRUPTED";
        }
        case "CRASHED": {
            return "CRASHED";
        }
        case "COMPLETED_WITH_ERRORS": {
            return "FAILED";
        }
        case "EXPIRED": {
            return "EXPIRED";
        }
        case "TIMED_OUT": {
            return "TIMED_OUT";
        }
        default: {
            throw new Error(`Unknown status: ${status}`);
        }
    }
}
function safeParseJSON(data) {
    try {
        return JSON.parse(data);
    }
    catch (error) {
        return data;
    }
}
const isSafari = () => {
    // Check if we're in a browser environment
    if (typeof window !== "undefined" &&
        typeof navigator !== "undefined" &&
        typeof navigator.userAgent === "string") {
        return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) ||
            /iPad|iPhone|iPod/.test(navigator.userAgent));
    }
    // If we're not in a browser environment, return false
    return false;
};
/**
 * A polyfill for `ReadableStream.protototype[Symbol.asyncIterator]`,
 * aligning as closely as possible to the specification.
 *
 * @see https://streams.spec.whatwg.org/#rs-asynciterator
 * @see https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream#async_iteration
 *
 * This is needed for Safari: https://bugs.webkit.org/show_bug.cgi?id=194379
 *
 * From https://gist.github.com/MattiasBuelens/496fc1d37adb50a733edd43853f2f60e
 *
 */
if (isSafari()) {
    // @ts-ignore-error
    ReadableStream.prototype.values ??= function ({ preventCancel = false } = {}) {
        const reader = this.getReader();
        return {
            async next() {
                try {
                    const result = await reader.read();
                    if (result.done) {
                        reader.releaseLock();
                    }
                    return result;
                }
                catch (e) {
                    reader.releaseLock();
                    throw e;
                }
            },
            async return(value) {
                if (!preventCancel) {
                    const cancelPromise = reader.cancel(value);
                    reader.releaseLock();
                    await cancelPromise;
                }
                else {
                    reader.releaseLock();
                }
                return { done: true, value };
            },
            [Symbol.asyncIterator]() {
                return this;
            },
        };
    };
    // @ts-ignore-error
    ReadableStream.prototype[Symbol.asyncIterator] ??= ReadableStream.prototype.values;
}
//# sourceMappingURL=runStream.js.map