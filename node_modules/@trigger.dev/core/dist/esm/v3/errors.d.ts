import { z } from "zod";
import { DeploymentErrorData } from "./schemas/api.js";
import { ImportTaskFileErrors, WorkerManifest } from "./schemas/build.js";
import { SerializedError, TaskRunError, TaskRunErrorCodes, TaskRunInternalError } from "./schemas/common.js";
import { TaskMetadataFailedToParseData } from "./schemas/messages.js";
import { ExceptionEventProperties } from "./schemas/openTelemetry.js";
/**
 * If you throw this, it will get converted into an INTERNAL_ERROR
 */
export declare class InternalError extends Error {
    readonly code: TaskRunErrorCodes;
    readonly skipRetrying: boolean;
    constructor({ code, message, showStackTrace, skipRetrying, }: {
        code: TaskRunErrorCodes;
        message?: string;
        showStackTrace?: boolean;
        skipRetrying?: boolean;
    });
}
export declare function isInternalError(error: unknown): error is InternalError;
export declare class AbortTaskRunError extends Error {
    constructor(message: string);
}
/**
 * This causes an Out Of Memory error on the run (if it's uncaught).
 * This can be useful if you use a native package that detects it's run out of memory but doesn't kill Node.js
 */
export declare class OutOfMemoryError extends Error {
    constructor();
}
export declare function isManualOutOfMemoryError(error: TaskRunError): boolean;
export declare class TaskPayloadParsedError extends Error {
    readonly cause: unknown;
    constructor(cause: unknown);
}
export declare function parseError(error: unknown): TaskRunError;
export declare function createErrorTaskError(error: TaskRunError): any;
export declare function createJsonErrorObject(error: TaskRunError): SerializedError;
export declare function sanitizeError(error: TaskRunError): TaskRunError;
export declare function shouldRetryError(error: TaskRunError): boolean;
export declare function correctErrorStackTrace(stackTrace: string, projectDir?: string, options?: {
    removeFirstLine?: boolean;
    isDev?: boolean;
}): string;
export declare function groupTaskMetadataIssuesByTask(tasks: any, issues: z.ZodIssue[]): Record<number, {
    id: any;
    exportName: string;
    filePath: string;
    issues: Array<{
        message: string;
        path?: string;
    }>;
}>;
export declare class UncaughtExceptionError extends Error {
    readonly originalError: {
        name: string;
        message: string;
        stack?: string;
    };
    readonly origin: "uncaughtException" | "unhandledRejection";
    constructor(originalError: {
        name: string;
        message: string;
        stack?: string;
    }, origin: "uncaughtException" | "unhandledRejection");
}
export declare class TaskMetadataParseError extends Error {
    readonly zodIssues: z.ZodIssue[];
    readonly tasks: any;
    constructor(zodIssues: z.ZodIssue[], tasks: any);
}
export declare class TaskIndexingImportError extends Error {
    readonly importErrors: ImportTaskFileErrors;
    readonly manifest: WorkerManifest;
    constructor(importErrors: ImportTaskFileErrors, manifest: WorkerManifest);
}
export declare class UnexpectedExitError extends Error {
    code: number;
    signal: NodeJS.Signals | null;
    stderr: string | undefined;
    constructor(code: number, signal: NodeJS.Signals | null, stderr: string | undefined);
}
export declare class CleanupProcessError extends Error {
    constructor();
}
export declare class CancelledProcessError extends Error {
    constructor();
}
export declare class SigKillTimeoutProcessError extends Error {
    constructor();
}
export declare class GracefulExitTimeoutError extends Error {
    constructor();
}
type ErrorLink = {
    name: string;
    href: string;
    magic?: "CONTACT_FORM";
};
type EnhanceError<T extends TaskRunError | ExceptionEventProperties> = T & {
    link?: ErrorLink;
};
export declare function taskRunErrorEnhancer(error: TaskRunError): EnhanceError<TaskRunError>;
export declare function exceptionEventEnhancer(exception: ExceptionEventProperties): EnhanceError<ExceptionEventProperties>;
export declare function internalErrorFromUnexpectedExit(error: UnexpectedExitError, dockerMode?: boolean): TaskRunInternalError;
export declare function serializeIndexingError(error: unknown, stderr?: string): DeploymentErrorData;
export declare function prepareDeploymentError(errorData: DeploymentErrorData): DeploymentErrorData | undefined;
export declare function createTaskMetadataFailedErrorStack(data: z.infer<typeof TaskMetadataFailedToParseData>): string;
export {};
